<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="../styles/style.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Gidole&display=swap" rel="stylesheet">
    <title>VFX: Sistema de partículas e Shader Graph</title>
</head>
<body>
    <header class="header"> 
        <nav>
        <ul class="menu">
            <li><a href="../index.html">Home</a></li>
            <li><a href="/">Recursos (Jogos)</a></li>
            <li><a href="/">Contato</a></li>
        </ul>
    </nav>
    </header>
    <div class="comp-jogos-header">VFX</div>
    <div class="summary">
        <br><br>
        <div class="comp-jogos-content-header">Sumário</div>
        <ol>
            <li><a href="#particles">Sistema de Partículas</a></li>
            <li><a href="#shader-graph-intro">Introdução ao Shader Graph</a></li>
            <li><a href="#criando-shader">Como criar um shader</a></li>
            <li><a href="#shader-graph-interface">A interface do Shader Graph</a></li>
            <li><a href="#shader-simples">Shader simples</a></li>
            <li><a href="#texturas-e-uvs">Texturas e UVs</a></li>
            <li><a href="#transparencia">Transparência / Alpha</a></li>
            <li><a href="#vertex">Vertex Shader</a></li>
        </ol>
    </div>
    <div class="comp-jogos-content">
        <div class="comp-jogos-content-header" id="shader-graph-intro">Shader Graph</div>
        <p>Shaders são os pais ou modelos dos materiais. Um material nada mais é do que uma instância de um shader. Portanto, o shader determina o comportamento (se irá haver uma textura, uma cor, transparência, reflexão, ou até aspectos mais complexos, como algum elemento procedural, noise, etc) enquanto que o material é responsável pelos atributos (qual é a cor, qual é a textura, quanto de transparência, impacto do noise...).</p>
        <p>Shader Graph é uma ferramenta visual dentro do Unity que permite criar shaders de forma intuitiva, sem a necessidade de escrever código manualmente. </p>
        <p>Para começar a usar o Shader Graph, será necessário ter um projeto configurado com o URP (Universal Render Pipeline). Em seguida, basta criar um novo Shader Graph:</p>
    </div>
    <div class="comp-jogos-content">
        <div class="comp-jogos-content-header" id="criando-shader">Como criar um shader</div>
        <ol>
            <li>Clique com o botão direito na janela do Project.</li>
            <li>Selecione Create &gt; Shader Graph &gt; URP &gt; Unlit Shader Graph.</li>
            <li><img src="../assets/shadergraph.png" alt="ShaderGraph 1" width="50%"></li>
            <li>Dê um nome ao seu shader.</li>
        </ol>
    
    <p>Vamos criar nosso primeiro shader?</p>
    <p>Nosso primeiro shader vai ser responsável por determinar a cor de um objeto 3D.</p>
    <p>Crie uma pasta com o nome Shaders e entre na pasta.</p>
    <p>Crie seu shader e dê um nome a ele. Em seguida, clique duas vezes no arquivo criado para abrir a janela do Shader Graph.</p>
    <img src="../assets/meu-primeiro-shader.png" width="50%" alt="Meu primeiro shader">
    <br><br>
    <div class="comp-jogos-content-header" id="shader-graph-interface">A interface</div><br>
    <img src="../assets/shader-graph-interface.png" width="100%" alt="Interface Shader Graph">
    <p>A interface do Shader Graph pode ser dividida em três áreas importantes:</p>
    <ol>
        <li>Do lado esquerdo temos o <b>Blackboard</b> - responsável por guardar todas as variáveis que nosso shader vai precisar: cores, texturas, floats, vetores, etc.</li>
        <li>No meio temos a <b>área de trabalho</b> - é onde criaremos todos os <b>nodos/nodes</b> que alterarão o shader - repare que já existe o "master node" criado: todas as alterações que fizermos vão culminar nos inputs de Vertex e Fragment (mais sobre eles em breve!)</li>
        <li>Do lado direito temos o <b>Graph Inspector</b> - é nele que iremos alterar as propriedades da variável, node ou do shader inteiro.</li>
    </ol>
    <div class="comp-jogos-content-header" id="shader-simples">Shader simples</div>
    <ol>
        <li>Vamos começar simples, alterando a cor do nosso shader:</p></li>
        <li>No <b>master node</b>, clique na caixa de cor do Fragment e coloque alguma cor que não seja cinza.</li>
        <li>Em seguida, salve usando Ctrl + S ou clicando no disquete no canto superior esquerdo da tela.</li>
        <li>Agora, de volta à Unity, clique com o botão direito no seu shader > Create > Material. Dê um nome ao material.</li>
        <li>Crie agora um objeto 3D na Unity, de preferência uma esfera ou cápsula.</li>
        <li>Arraste seu material para o objeto 3D. Deu certo?</li>
        <li>Agora, crie mais dois materiais com o mesmo shader e coloque em mais dois objetos 3D</li>
        <li>Aqui encontramos um problema: todos os nossos materiais usam sempre a mesma cor... e a ideia é que os nossos shaders sejam configuráveis!</li>
        <li>Para melhorar nosso shader, vamos abrí-lo na janela de Shader Graph novamente, e dessa vez vamos no <b>Blackboard</b></li>
        <li>Clique no símbolo de + e selecione Color. Dê um nome a essa variável, como "Base Color".</li>
        <li>Arraste a variável e arraste para a área de trabalho.</li>
        <li>Foi criado um novo <b>node</b>, que conta com uma saída. Clique e segure na saída (output) para ligá-lo à entrada (input) do Base Color, dentro de Fragment</li>                                                            <li>Isso fará com que essa propriedade (variável) controle a cor base do nosso shader.</li>
        <li><img src="../assets/shader-graph-base-color.png"></li>
        <li>Você pode selecionar a variável criada e alterar seu valor padrão através do Graph Inspector.</li>
        <li>Salve e volte para a Unity. Selecione um dos materiais criados. Repare que foi criado um novo campo no <b>inspector</b>. Altere a cor dos três materiais que você criou.</li>
    </ol>
    <div class="comp-jogos-content-header" id="texturas-e-uvs">Texturas e UVs</div>
    <p>Todas as texturas usadas nesse material foram tiradas de <a href="https://ambientcg.com/">https://ambientcg.com/</a> e <a href="https://polyhaven.com/">https://polyhaven.com/</a></p>
    <div class="importante">Antes de começarmos, duplique o seu shader anterior para trabalharmos com uma versão melhorada dele!
        <br>É possível duplicar o shader selecionado o arquivo e pressionando Ctrl+D</div>
    <p>É possível misturar uma cor base (como a que já temos) com uma textura. Isso é bem comum!</p>
    <p>Para isso, vamos criar uma nova propriedade (variável) no Blackboard com o tipo Texture2D.</p>
    <p>Com a propriedade selecionada, você pode escolher uma textura padrão para esse shader: no Graph Inspector, no espaço "Default Value", selecione a textura desejada. Caso você tenha baixado uma textura completa (com mapa normal, ambient occlusion, etc.), normalmente a textura desejada vai ter o nome "albedo" ou "color".</p>
    <p>Arraste a variável para a área de trabalho. O node criado é um pouco diferente, ele, inclusive, não pode ser ligado diretamente ao "base color" do Fragment, como fizemos da última vez.</p>
    <p>Para usar uma textura, precisamos de um node chamado Sample Texture 2D. Esse node é responsável por "ler" a textura e fornecer a cor correta para cada pixel do objeto 3D.</p>
    <p>Crie esse node clicando com o botão direito na área de trabalho > Create Node > procure por "Sample Texture 2D" - você também pode apertar a barra de espaço para abrir a janela de criação de nodes.</p>
    <p>Esse node tem como input uma textura, uma UV e um sampler. No momento o que nos interessa é a textura, que já temos! Agora basta ligar a nossa textura (node) ao Sample Texture 2D</p>
<p>Já a saída desse node são cores: RGBA para uma combinação de todas as cores da textura (incluindo transparência) ou então as cores separadamente, caso desejado.</p>
<p>Por fim, para combinar a cor base com a textura, precisamos multiplicar as cores. Essa é uma das formas de combinar cores, mas não é a única.</p>
<p>Para isso, crie um node <b>multiply</b> que terá como entrada a base color e o RGBA da textura. A saída do multiply deve ir para o base color do Fragment.</p>
<p><img src="../assets/texture-shader.png" width="75%"></p>    
<p><img src="../assets/resultado-texture-shader.png" width="75%"></p>
<div class="aviso">Vamos experimentar algo mais divertido?</div>
<p>Crie uma nova propriedade "Scroll Velocity" - essa variável do tipo Vector2 vai determinar a velocidade que nossa textura se move pelo objeto. Altere o valor base para X = 1, Y = 0</p>
<p>Para "animar" esses valores, vamos usar um novo node: <b>Time</b>. </p>
<p>Multiplique Scroll Velocity por Time usando o node Multiply - esse será um Vector2 que aumenta com o tempo.</p>
<p>Crie um novo node Tiling And Offset - conecte a saída do Multiply à entrada "Offset" deste node.</p>
<p>Por fim, conecte o output do Tiling and Offset à entrada "UV" do Sample Texture 2D</p>
<p>Salve e veja o resultado! Experimente com outros valores no Scroll Velocity.</p>
<div class="aviso">Você pode perceber que na Unity o efeito só sofre alteração quando você mexe o mouse ou realiza alguma ação. Experimente posicionar a câmera corretamente e dar Play no jogo!
    Você também pode fazer com que a cena sempre atualize:</div>
    <img src="../assets/shader-always-refresh.png" width="25%" alt="Shader Always Refresh">
</div>
<div class="comp-jogos-content">
    <div class="comp-jogos-content-header" id="transparencia">Transparência / Alpha</div>
    <div class="importante">Antes de começarmos, duplique o seu shader anterior para trabalharmos com uma versão melhorada dele! No shader duplicado, remova toda a lógica de scrolling (movimentação) de textura.</div>
    <p>Para iniciarmos, é preciso alterar uma configuração no nosso Shader: queremos que o material seja entendido como <b>transparente</b>, e não <b>opaco</b></p>
    <p>Para isso, vamos no Graph Inspector > <b>Graph Settings</b> e vamos trocar o <b>Surface Type</b> para <b>Transparent</b></p>
    <p>Com isso, uma nova entrada vai aparecer em Fragment: <b>Alpha</b> - responsável por controlar a transparência do material.</p>
    <p>A gente quer que a cor base do nosso material seja responsável por controlar a transparência. Para isso, precisar pegar só o valor do Alpha depois da multiplicação entre Textura e Cor Base</p>
    <p>Felizmente existe um node para isso! Após o Multiply, adicione o node <b>Split</b>, que vai dividir o nosso valor RGBA em R, G, B e A. Puxe o A para o Alpha. </p>
    <img src="../assets/shader-transparency.png" width="75%" alt="Shader Transparência">
    <br>
    <div class="comp-jogos-content-header">Alpha Clipping</div>
    <p>Alpha também pode ser usado para remover partes de um objeto. Com o Alpha Clipping, qualquer cor abaixo de um certo valor pode ser removida.</p>
    <p>Vamos criar mais um shader baseado no exemplo de transparência (lembre de duplicar e abrir o novo)</p>
    <p>No Graph Settings, troque o Surface Type de Transparent para Opaque (queremos que nosso objeto seja opaco!)</p>
    <p>Ative o <b>Alpha Clipping</b> - uma nova entrada vai aparecer em Fragment, chamada <b>Alpha Clip Threshold</b></p>
    <p>Crie uma nova propriedade (variável) do tipo Float, chamada Alpha Clip Threshold. Dê um valor padrão de 0.5</p>
    <p>Arraste a variável para a área de trabalho e conecte ao Alpha Clip Threshold do Fragment</p>
    <p>Agora, crie um novo objeto e coloque esse novo material nele. Escolha uma textura que tenha partes pretas, como um brilho (branco)</p>
    <p>Altere o valor do Alpha Clip Threshold e veja o que acontece com o material.</p>
    <img src="../assets/shader-alpha-clipping.png" width="75%" alt="Alpha Clipping">
    <img src="../assets/shader-alpha-clipping-resultado.png" width="75%" alt="Alpha Clipping Result">
    <div class="comp-jogos-content-header">Dithering</div>
    <p>Outra forma de trabalhar com transparência é usando dithering. Dithering é um efeito que cria a ilusão de transparência através de um padrão de pontos, ao invés de usar transparência real.</p>
    <p>Vamos criar mais um shader baseado no exemplo de alpha clipping (lembre de duplicar e abrir o novo)</p>
    <p>Remova a propriedade "Alpha Clip Threshold" e o node na área de trabalho.</p>
    <p>Crie um node "Dither" - ligue ele ao Alpha Clip Threshold no Fragment. Dê ao Dither o valor fixo 1</p>
    <p>Crie um novo material com esse shader e altere o alpha da Base Color</p>
    <img src="../assets/shader-dither.png" width="75%" alt="Dithering">
    <img src="../assets/shader-dither-resultado.png" width="75%" alt="Dithering Result">
</div>
<!-- 
<div class="comp-jogos-content">
    <div class="comp-jogos-content-header"id="depth-buffer">Depth Buffer</div>
    <p>O Depth Buffer (ou Z-buffer) é uma técnica usada em gráficos 3D para gerenciar a profundidade dos objetos em uma cena. Ele armazena informações sobre a distância de cada pixel em relação à câmera, permitindo que o sistema de renderização determine quais objetos estão na frente ou atrás de outros.</p>
    <p>Existe uma parte mais técnica que dá para se aprofundar, mas não cabe no escopo deste material</p>
    <p>Para entender um pouco melhor como funciona, vamos duplicar o shader mais simples, o de cor, em que criamos uma variável do tipo Color e levamos para o Fragment (Base Color).</p>
    <p>A parte importante vem agora: no Graph Settings, conseguimos alterar o Depth Write e o Depth Test</p>
    <p>O Depth Write determina se o shader escreve ou não no Depth Buffer. </p>
    <ul>
        <li>ForceEnabled: O shader sempre escreve no Depth Buffer. - bom para alguns efeitos específicos</li>
        <li>ForceDisabled: O shader não escreve no Depth Buffer. - bom para objetos translúcidos e outros efeitos</li>
        <li>Auto: Unity escreve no Depth Buffer para materiais opacos, mas não para materiais transparentes.</li>
    </ul>
    <p>Vamos manter como Auto</p>
    <p>O Depth Test determina como o shader interage com o Depth Buffer existente. Existem várias opções, mas as mais comuns são:</p>
    <ul>
        <li>LEqual (padrão): Less or equal - escreve o pixel se a profundidade for mais próxima ou igual ao valor na textura de profundidade</li>
        <li>Less: O pixel é desenhado se estiver mais próximo da câmera do que o pixel existente no Depth Buffer.</li>
        <li>Greater: O pixel é desenhado se estiver mais distante da câmera do que o pixel existente no Depth Buffer.</li>
        <li>Equal: O pixel é desenhado se estiver na mesma distância da câmera que o pixel existente no Depth Buffer.</li>
        <li>Always: O pixel é sempre desenhado, ignorando o Depth Buffer. Isso pode ser útil para efeitos especiais, mas pode causar problemas de sobreposição.</li>
    </ul>
    <p>Fora isso, é interessante deixar a opção "Allow Material Override" marcado, para que você possa editar essas opções para cada material criado a partir deste shader.</p>
    <div class="importante">Atenção! Dependendo da versão da Unity e URP que estamos usando, pode ser necessário ativar a Depth Texture nas configurações. Um lugar comum para encontrar essas configurações é em Assets > PC_RPAsset > Depth Texture (marcar)</div>
    <p>Vamos para o shader?</p>
    <p>Este shader vai servir para criar a silhueta de um objeto 3D quando estiver por trás de um outro objeto, parede, etc.</p>
    <p>Ao criar o shader e dar um nome, abra e mude o Graph Settings > Surface Type para Transparent</p>
    <p>Crie duas novas propriedade do tipo Color, chamadas "Foreground Color" e "Background Color". Dê cores diferentes para cada uma.</p>
    <p>Crie um novo node: Scene Depth - responsável por percorrer a textura de profundidade (Depth Texture), nele, escolha a opção "Linear01". As outras opções têm outras aplicações.</p>
    <p>Crie um novo node: Lerp - faz a interpolação linear entre A e B de acordo com T (T indo de 0 a 1).</p>
    -->
</div>
<div class="comp-jogos-content">
    <div class="comp-jogos-content-header" id="vertex"> Vertex Shader</div>
    <p>A parte Vertex do nosso Master Node é responsável por cuidar da posição, normal e tangente dos vértices do modelo 3D.</p>
    <p>Vamos criar um shader que "ondula" a superfície de um objeto 3D, como se fosse água.</p>
    <p>Crie um Unlit Shader Graph novo - dê um nome.</p>
    <p>No Blackboard, crie duas propriedades: Wave Speed e Wave Strength -- ambas float</p>
    <p>Crie um node "Position", com Space "World". Esse node te retorna a posição de um vértice da malha.</p>
    <p>Crie também o node "Time", multiplicando "Time" por "Wave Speed"</p>
    <p>Como só queremos mexer no X e Z do objeto, vamos precisar usar o node "Split" para dividir a saída de "Position"</p>
    <p>Em seguida, adicionamos (com o node Add) esses dois valores e adicionamos com a saída da multiplicação anterior.</p>
    <p>Então, usamos o node Sine para transformar o resultado numa senoide</p>
    <p>Multiplicamos o resultado do senoide pela propriedade Wave Strength...</p>
    <p>E finalmente, criamos um Vector3 (node) substituindo seu Y pelo resultado da multiplicação</p>
    <p>Agora é só somar esse resultado com a saída de um node Position no Space Object</p>
    <p>E pronto! Só ligar ao Vertex - Position</p>
    <div class="aviso">Esse não foi tão simples assim, né?</div>
    <p>Agora é só criar um material novo e colocar num objeto. Sugestão: faça isso num Plane.</p>
    <p>Segue a colinha: ;)</p>
    <img src="../assets/vertex-shader.png" width="75%" alt="Shader Vertex Wave">
    <img src="../assets/vertex-shader-resultado.png" width="75%" alt="Shader Vertex Wave Result">
</div>

<div class="comp-jogos-content">
    <div class="comp-jogos-content-header" id="post-processing"> Pós-processamento</div>
    <p>O pós-processamento é uma etapa crucial na criação de gráficos visuais impressionantes em jogos e aplicações 3D. Ele envolve a aplicação de efeitos visuais adicionais após a renderização inicial da cena, aprimorando a qualidade visual e a atmosfera do ambiente.</p>
    <p>Na Unity, o pós-processamento é frequentemente gerenciado através do componente "Volume", que vem junto com o URP. Esse componente oferece uma variedade de efeitos que podem ser facilmente aplicados e ajustados para alcançar o visual desejado.</p>
    <p>Alguns dos efeitos de pós-processamento mais comuns incluem:</p>
    <ul>
        <li><b>Bloom:</b> Cria um efeito de brilho ao redor de áreas brilhantes da cena, simulando a dispersão da luz.</li>
        <li><b>Depth of Field:</b> Simula o foco da câmera, desfocando objetos que estão fora do plano focal, criando um efeito de profundidade.</li>
        <li><b>Color Grading:</b> Permite ajustar as cores da cena para criar diferentes atmosferas e estilos visuais.</li>
        <li><b>Motion Blur:</b> Adiciona um efeito de desfoque em objetos em movimento, aumentando a sensação de velocidade.</li>
        <li><b>Vignette:</b> Escurece as bordas da tela, focando a atenção do jogador no centro da imagem.</li>
    </ul>
    <p>Para configurar o pós-processamento na Unity, siga estes passos básicos:</p>
    <ol>
        <li>Instale e configure o URP (já deve estar pronto)</li>
        <li>Adicione um objeto com o componente Volume à sua cena.</li>
        <li>Crie um perfil de pós-processamento e adicione efeitos</li>
        <li>Ajuste os parâmetros de cada efeito para alcançar o visual desejado.</li>
        <li>Na câmera do jogo, marque a opção "Post Process"</li>
        <li>Pode ser necessário ir nas configurações do Renderer (por padrão o nome é PC_Renderer ou Mobile_Renderer) e marcar a opção de Post Processing</li>
    </ol>
    <p>O pós-processamento pode transformar significativamente a aparência de uma cena, tornando-a mais realista, estilizada ou atmosférica, dependendo dos efeitos escolhidos e de como são aplicados.</p>
    <div class="importante">Lembre-se de que o uso excessivo de efeitos de pós-processamento pode impactar o desempenho do jogo, especialmente em dispositivos com hardware limitado. É importante equilibrar a qualidade visual com a performance para garantir uma experiência de jogo suave.</div>   
</div>
<div class="comp-jogos-content">
    <div class="comp-jogos-content-header" id="scripting">Alterando parâmetros de materiais e pós-processamento com scripts</div>
    <p>É possível alterar parâmetros de materiais e efeitos de pós-processamento através de scripts em C#. Isso permite criar efeitos dinâmicos e interativos em resposta a eventos do jogo ou ações do jogador.</p>
    <p>Para alterar parâmetros de materiais, você pode acessar o componente Renderer do objeto e modificar as propriedades do material. Por exemplo:</p>
<pre class="prettyprint">
                <code>
using UnityEngine;  
public class ChangeMaterialColor : MonoBehaviour  
{  
    public Color newColor;  
    private Renderer objRenderer;  

    void Start()  
    {  
        objRenderer = GetComponent<Renderer>();  
        objRenderer.material.color = newColor;  
    }  
}
</pre></code>
<p>Também é possível alterar parâmetros de shaders criados por você</p>
<pre class="prettyprint">
                <code>
using UnityEngine;
public class ChangeFresnelPower : MonoBehaviour
{
    public float fresnelPower = 1.5f; // Novo valor para a propriedade do shader
    private Renderer objRenderer;
    void Start()
    {
        objRenderer = GetComponent<Renderer>();
        objRenderer.material.SetFloat("_FresnelPower", fresnelPower); // "_FresnelPower" seria o nome da propriedade no shader
    }
}
</pre></code>
    <div class="aviso">Atenção! O nome da propriedade do shader (no exemplo, "_FresnelPower") deve ser exatamente igual ao que foi definido no campo "Reference" do shader.</div>
    <img src="../assets/fresnel-power.png" alt="Fresnel Power Reference">
    <p>Para alterar parâmetros de pós-processamento, você pode acessar o componente PostProcessVolume e modificar os efeitos diretamente. Por exemplo, para alterar a intensidade do Bloom:</p>
    <pre class="prettyprint">
                <code>
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class ChangeBloomIntensity : MonoBehaviour
{   
    public Volume postProcessVolume; // Coloque o Volume de pós-processamento no Inspector
    private Bloom bloom;

    void Start()
    {
        if (postProcessVolume.profile.TryGet<Bloom>(out bloom))
        {
            bloom.intensity.value = 5f; // Define a nova intensidade do Bloom
        }
    }
}

</code></pre>
<div class="importante">Muita atenção! A forma que esses parâmetros são alterados pode ser diferente dependendo da versão da Unity ou do URP / Shader Graph / Post Processing.</div>
</div>
</div>
</div>
</div>
</div>
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</body>
</html>