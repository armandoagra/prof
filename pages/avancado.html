<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="../styles/style.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Gidole&display=swap" rel="stylesheet">
    <title>Recursos avançados</title>
</head>
<body>
    <header class="header"> 
        <nav>
        <ul class="menu">
            <li><a href="../index.html">Home</a></li>
            <li><a href="/">Recursos (Jogos)</a></li>
            <li><a href="/">Contato</a></li>
        </ul>
    </nav>
    </header>
    <div class="comp-jogos-header">RECURSOS AVANÇADOS</div>
    <div class="summary">
        <br><br>
        <div class="comp-jogos-content-header">Sumário</div>
        <ol>
            <li><a href="#jam">Desespero Game Jam</a></li>
            <li><a href="#git">Controle de versão: Git</a></li>
            <li><a href="#probuilder">Greyboxing: ProBuilder</a></li>
            <li><a href="#scriptable-objects">ScriptableObjects</a></li>
            <li><a href="#urp">URP: Universal Render Pipeline</a></li>
        </ol>
    </div>
    <div class="comp-jogos-content">
        <div class="comp-jogos-content-header" id="jam"> Desespero Game Jam</div>
        <p>Se inicia hoje a DESESPERO GAME JAM! A jam tem uma duração de 4 semanas, se iniciando no dia 22/04 e finalizando em 16/05.</p>
        
        <p>A nossa jam terá algumas regras...</p>
        
        <div class="comp-jogos-content-header">
            <ol>
                <li>Grupos de 4 ou 5 pessoas</li>
                <li>Jogo CURTÍSSIMO!</li>
                <li>Entregas semanais (design, artes, mecânicas)</li>
                
                <li>Um tema a ser seguido:</li>
            </ol>
        </div>
        
        <button onclick="ShowText()" id="hide-this-after">Clique para revelar!</button>
        <div id="hidden-div" style="display:none" class="comp-jogos-content-header"> Pequenas grandes descobertas </div>
        <br><br>
        Também teremos alguns diversificadores, que vocês poderão escolher para adicionar ao jogo:
        <br><br>
        <div class="comp-jogos-content-header">
            <ol>
                <li><strong>Campina é meu mundo:</strong> seu jogo se passa em algum lugar de Campina Grande;</li>
                <li><strong>Coisas fantásticas:</strong> seu jogo aborda, de alguma forma, algum tema fantástico, como magia ou criaturas.</li>
                <li><strong>Dimensões:</strong> seu jogo brinca com as dimensões de elementos: algumas coisas podem ser bem menores ou bem maiores que o esperado.</li>
                <li><strong>Eu conheço essa pessoa:</strong> seu personagem principal é baseado em alguma pessoa da vida real (não necessariamente alguém que vocês conhecem pessoalmente)</li>
                <li><strong>Surpresa!:</strong> inclua algum plot twist em algum momento do seu jogo</li>
                <li><strong>Partidas rápidas:</strong> cada partida ou rodada do seu jogo dura até 15 segundos (mas, claro, cada partida é diferente)</li>
                <li><strong>Precisa nem de legenda:</strong> a história do seu jogo é dublada por um de vocês</li>
            </ol>
        </div>

    </div>

    <div class="comp-jogos-content">
        <div class="comp-jogos-content-header" id="git">Controle de versão: Git</div>
        <p>Link para a <a href="https://drive.google.com/file/d/1RHUxAlONWq191ZbxJ2KrSDUkJjMckBSD/view">colinha</a></p>
        <p>Usado para rastrear mudanças do projeto e colaborar com os colegas de equipe</p>
        <p>Git é um sistema de controle de versão distribuído, o que significa que cada desenvolvedor tem uma cópia completa do repositório em sua máquina local. Isso permite que os desenvolvedores trabalhem offline e façam alterações sem depender de uma conexão com a internet.</p>
        <p>GitHub é uma plataforma de hospedagem de código-fonte que utiliza o Git como sistema de controle de versão. Ele permite que os desenvolvedores colaborem em projetos, compartilhem código e gerenciem problemas.</p>
        <p>Git é amplamente utilizado na indústria de software e é uma habilidade essencial para desenvolvedores. Ele permite que os desenvolvedores trabalhem de forma mais eficiente, colaborem com outros e mantenham um histórico completo de todas as alterações feitas em um projeto.</p>
        <p>Existem diversas formas de trabalhar com Git e GitHub. Dá para usar o Git via prompt de comando ou com interfaces gráficas. Para facilitar, iremos trabalhar com o <a href="https://desktop.github.com">GitHub Desktop</a></p>
        <p>Após a instalação, o responsável pelo projeto deve criar um novo repositório no GitHub, assim como inicializar o projeto no GitHub Desktop. Acompanhe a colinha para ver um passo a passo.</p>
    </div>

    <div class="comp-jogos-content">
        <div class="comp-jogos-content-header" id="probuilder">Greyboxing: ProBuilder</div>
        <p>Nessa primeira etapa do desenvolvimento do jogo, precisamos começar a prototipar as principais partes do nosso jogo. Dependendo do jogo, pode ser importante trabalhar primeiro no cenário do jogo. No caso do meu jogo que será desenvolvido nessa competência, o trabalho de level design é extremamente importante! Então veremos como trabalhar com o ProBuilder para construir o cenário inicial do meu jogo.</p>
        <p>Existem outras soluções para jogos que não se beneficiem do ProBuilder: 2D Tilemap Editor, Terrain Tools </p>
        <iframe width="560" height="315" src="https://www.youtube.com/embed/YsBniZ5ya7k?si=1ZhL7tEZ8m4uY5aI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <p>No vídeo acima, temos um tutorial da Unity de como trabalhar com o ProBuilder e a importância do grayboxing.</p>
        <p>Greyboxing (ou grayboxing) serve para criar uma base do seu cenário 3D sem ter que necessariamente modelar os objetos 3D. É feita uma composição básica diretamente na Unity, onde você pode testar como seu nível ficará, identificando problemas. </p>
        <ul>
            <li>Após a instalação, o ProBuilder fica disponível tanto no menu de criação de assets como também em Tools/ProBuilder e também na caixa flutuante de ferramentas, na Scene.</li>
            <li>Para criar um novo objeto, clique em "New Shape" e escolha o tipo de objeto que você quer criar. Você pode criar cubos, esferas, cilindros, entre outros.</li>
            <li><img src="../assets/probuilder-1.png" alt="ProBuilder 1"></li>
            <li>Após criar um objeto, é possível editar suas propriedades básicas (tamanho, por exemplo) e algumas específicas: quantidade de lados, suavização, preenchimento...</li>
            <li><img src="../assets/probuilder-2.png" alt="ProBuilder 2"></li>
            <li>Além disso, também é possível editar detalhes técnicos da malha, como a posição de vértices, arestas e faces</li>
            <li><img src="../assets/probuilder-3.png" alt="ProBuilder 3"></li>
            <li>Ao selecionar alguma das opções acima, como a de faces, e selecionar uma face e clicar com o botão direito, é possível acessar mais um menu com opções para faces, permitindo a extrusão, subdivisão, triangulação, entre outros.</li>
            <li><img src="../assets/probuilder-4.png" alt="ProBuilder 4"></li>
        </ul>
        <div class="comp-jogos-content-header">Em sala...</div>
        <p>É hora de se juntar com sua equipe e montar os níveis iniciais do seu jogo.</p>
        <p>A sua equipe pode bolar o cenário no papel e trazer para a Unity quando tiver uma versão apropriada.</p>
        <p>Atenção: quem deve montar o cenário na Unity deve ser o Level Designer ou o Game Designer!</p>
    </div>
    <div class="comp-jogos-content">
        <div class="comp-jogos-content-header" id="scriptable-objects">ScriptableObjects</div>
        <p>ScriptableObjects são uma forma de armazenar dados em Unity. Eles são usados para criar objetos que podem ser facilmente editados e reutilizados em diferentes partes do seu projeto.</p>
        <p>ScriptableObjects são úteis para armazenar dados que não precisam ser atualizados em tempo real, como configurações de jogo, dados de personagens, itens, etc. Eles permitem que você crie objetos que podem ser facilmente editados no Inspector do Unity e reutilizados em diferentes partes do seu projeto.</p>
        <p>Para criar um ScriptableObject, você precisa criar uma nova classe que herda de ScriptableObject e adicionar os dados que deseja armazenar. Em seguida, você pode criar uma instância do ScriptableObject no Editor do Unity e editar os dados diretamente no Inspector.</p>
        <p>Exemplo de ScriptableObject:</p>
        
            <pre class="prettyprint">
                <code>
using UnityEngine;

<strong>[CreateAssetMenu(fileName = "NewCharacter", menuName = "Character")]</strong>
public class CharacterSO : <strong>ScriptableObject</strong>
{
    public string characterName;
    public int health;
    public int attackPower;
}
                </code>
            </pre>
        
        <p>Após criar o ScriptableObject, você pode criar uma instância dele no Editor do Unity clicando com o botão direito na pasta do projeto e selecionando Create > Character. Isso criará um novo arquivo que você pode editar diretamente no Inspector.</p>
        <p>Você pode, então, criar um script que referencie o CharacterSO para usar os atributos dele</p>
        <p class="importante">Importante! O ScriptableObject é um <strong>asset</strong>, um arquivo, que é criado. Ele não é um componente, script ou um MonoBehaviour que fica atrelado a um GameObject.</p>
    </div>

    <div class="comp-jogos-content">
        <div class="comp-jogos-content-header" id="urp">URP: Universal Render Pipeline</div>
        <p>O Universal Render Pipeline (URP) é um pipeline de renderização otimizado para PC, dispositivos móveis e VR. Ele oferece uma série de recursos avançados, como iluminação em tempo real, sombras dinâmicas e suporte a efeitos visuais avançados.</p>
        <p>O URP é projetado para ser fácil de usar e configurar, permitindo que os desenvolvedores criem gráficos de alta qualidade sem precisar se preocupar com a complexidade dos pipelines de renderização tradicionais.</p>
        <p>Novos projetos na Unity já vêm com o URP instalado, é só configurar e criar algo incrível!</p>
        <p>Por padrão, os arquivos de configuração são criados na pasta Assets/Settings/, mas também é possível criar outros arquivos de configuração</p>
        <p>Neles, podemos editar configurações de sombra, ambient occlusion, iluminação, entre outras.</p>
        <p>Com o URP também podemos criar shaders usando o shader graph e criar volumes de pós-processamento, além das outras características já citadas.</p>
        <p>Para modificar o pós-processamento, basta criar um novo GameObject > Volume > Global Volume e adicionar overrides</p>
        <p class="importante">Importante! Pode ser necessário habilitar o pós-processamento na câmera principal.</p>        
    </div>

    <div class="comp-jogos-content">
    <div class="comp-jogos-content-header" id="juice">Game Juice e Polishing</div>
        <p>Game Juice é o termo usado para descrever pequenos efeitos que fazem uma diferença em como o jogador vai experenciar seu jogo.</p>
        <p>Esses efeitos podem incluir animações, partículas, efeitos sonoros e outros elementos que tornam o jogo mais envolvente e divertido de jogar.</p>
        <p>Em geral, essas modificações não tem NENHUM impacto na gameplay, porém fazem toda a diferença para o jogador.</p>
        <p>Alguns exemplos incluem: 
            <ul>
                <li>Visual: animações, partículas, efeitos de tela, tremor na câmera/tela</li>
                <li>Sonoro: sons de impacto, sons de sucesso, sons dinâmicos, pitch variation, fade in/out</li>
                <li>Tátil: vibrações no controle</li>
            </ul>
        <p>A etapa de polishing de um jogo, ou refinamento, envolve a adição desses elementos de Game Juice, assim como correção de bugs, ajustes finos, entre outros.</p>
        <p>É impossível falar de Game Juice e não apresentar esse vídeo:</p>
        <iframe width="560" height="315" src="https://www.youtube.com/embed/Fy0aCDmgnxg?si=6TuyFjR-wu1fzLi_" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <p>Pensando no jogo que está sendo desenvolvido: o que você adicionaria? </p>
        <div class="comp-jogos-content-header" id="feel">Game Feel</div>
        <p>Game Feel é um outro termo extremamente importante, mas que dessa vez terá um impacto direto na gameplay do jogo</p>
        <p>É a sensação que o jogador tem ao jogar o jogo. Isso inclui a resposta do controle, a física do jogo, a animação e outros elementos que afetam como o jogador se sente ao jogar.</p>
        <p>A responsividade, o balanceamento, o peso e a fluidez do personagem são exemplos de aspectos do jogo que devem ser olhados com cuidado.</p>
        <p>Resposta imediata no input do jogador, aceleração e desaceleração com curvas, coyote time (muito importante em platformers!), input buffering, hit stop / slow-mo hits.</p>
        <p>Um pequeno adendo: muitas vezes os termos Feel e Juice são usados de forma equivalente, mas há quem prefira diferenciá-los</p>
        <iframe width="560" height="315" src="https://www.youtube.com/embed/216_5nu4aVQ?si=UP7uj6IV7jIKtA0j" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
    </div>
    <div class="comp-jogos-content">
    <div class="comp-jogos-content-header" id="heranca">POO: Herança</div>
        <p>Herança é um dos pilares da Programação Orientada a Objetos (POO). Ela permite que uma classe herde propriedades e métodos de outra classe, facilitando a reutilização de código e a criação de hierarquias de classes.</p>
        <p>Em Unity, a herança é frequentemente usada para criar classes base que podem ser estendidas por outras classes. Por exemplo, você pode ter uma classe base chamada "Enemy" que define propriedades e métodos comuns para todos os inimigos do jogo. Em seguida, você pode criar subclasses como "Zombie" e "Alien" que herdam de "Enemy" e adicionam suas próprias características específicas.</p>
        <p>Exemplo:</p>
        <pre class="prettyprint">
            <code>
using UnityEngine;
public class Enemy : MonoBehaviour
{
    public int health;
    public void TakeDamage(int damage)
    {
        health -= damage;
        if (health <= 0)
        {
            Die();
        }
    }
    public void Die()
    {
        Destroy(gameObject);
    }
}
</code>
</pre>
<pre class="prettyprint">
    <code>
public class Alien : <strong>Enemy</strong>
{
    public override void Die()
    {
        // Lógica de morte específica do alien
        Debug.Log("Alien died!");
        base.Die(); // Chama a lógica de morte da classe base
    }
}
    </code>
</pre>

<p>Com os scripts acima, podemos criar dois tipos de inimigos: um inimigo genérico (Enemy) e um Alien. Também poderíamos ter implementado uma lógica única para o zumbi, como dito antes dos exemplos.</p>

<div class="comp-jogos-content-header">Interface</div>
        <p>Interface é um contrato que define um conjunto de métodos que uma classe deve implementar. Em Unity, as interfaces são usadas para definir comportamentos comuns que podem ser aplicados a diferentes classes.</p>
        <p>Por exemplo, você pode ter uma interface chamada "IDamageable" que define um método "TakeDamage". Qualquer classe que implemente essa interface deve fornecer uma implementação para o método "TakeDamage". Isso permite que você crie classes que podem ser danificadas, independentemente de sua hierarquia de classes.</p>
        <pre class="prettyprint">
            <code>
public interface IDamageable
{
    void TakeDamage(int damage);
    void Die();
}
</code></pre>
        <p>Exemplo de implementação de uma interface:</p>
        <pre class="prettyprint">
            <code>
using UnityEngine;

public class Player : MonoBehaviour, IDamageable
{
    public int health;
    public void TakeDamage(int damage)
    {
        health -= damage;
        if (health <= 0)
        {
            Die();
        }
    }
    public void Die()
    {
        Debug.Log("Player died!");
        Destroy(gameObject);
    }
}
</code>
</pre>


<p>É importante saber também que quando um script implementa uma interface, o objeto passa a ser também desse tipo.</p>
<p>Por exemplo, se o Player implementa a interface IDamageable, podemos fazer:</p>
<pre class="prettyprint">
    <code>
        IDamageable damageable = player.GetComponent&lt;IDamageable&gt;();
        if (damageable != null)
        {
            damageable.TakeDamage(10);
        }
    </code>
</pre>
<p>Isso é útil para quando queremos aplicar um dano a qualquer objeto que implemente a interface, sem precisar saber exatamente qual é o tipo do objeto.</p>
<p>Uma outra aplicação é quando temos uma gama de objetos que são interativos, mas cada um tem sua própria classe:</p>
<ul>
    <li>Door.cs</li>
    <li>Chest.cs</li>
    <li>NPC.cs</li>
</ul>
<p>Todos esses objetos podem implementar uma interface chamada IInteractable, que define um método Interact(). Assim, podemos ter um script que interage com qualquer objeto que implemente essa interface, sem precisar saber qual é o tipo exato do objeto.</p>
<pre class="prettyprint">
    <code>
public interface IInteractable
{
    void Interact();
}
</code>
</pre>
<pre class="prettyprint">
    <code>
public class PlayerInteraction : MonoBehaviour {

    private void Update(){
        if (Input.GetKeyDown(KeyCode.E))
        {
            IInteractable interactable = GetObjectToInteractWith(); // Método que retorna o objeto a ser interagido
            InteractWithObject(obj);
        }
    }

    private IInteractable GetObjectToInteractWith(){
        // Raycast na frente do player
        RaycastHit hit;
        if (Physics.Raycast(transform.position, transform.forward, out hit, 3f))
        {
            GameObject obj = hit.collider.gameObject;
            IInteractable interactable = obj.GetComponent&lt;IInteractable&gt;();
            if (interactable != null)
            {
                return interactable;
            }
        }
        return null; 
    }

    private void InteractWithObject(IInteractable interactable)
    {
        if (interactable != null)
        {
            interactable.Interact();
        }
    }
}     
</code>   
</pre>
<p>Dessa forma, não importa qual seja o objeto, contanto que o script implemente a interface, poderemos interagir com ele.</p>
<p>Se não fizessemos dessa forma, provavelmente teríamos que criar uma grande estrutura condicional que verificasse se o objeto é uma porta, se é um baú, um NPC...</p>
<div class="comp-jogos-content-header">POO em outras engines.</div>
        <p>É importante ressaltar que a Programação Orientada a Objetos é um paradigma de programação que pode ser aplicado em diversas linguagens e engines, não apenas na Unity.</p>
        <p>Outras engines, como Unreal Engine, Godot e Construct, também suportam POO e oferecem recursos semelhantes para criar jogos orientados a objetos.</p>
        <p>Em Unreal Engine, por exemplo, você pode usar Blueprints para criar classes e heranças e interfaces de forma visual. Já no Construct, existem as "Families". Cada engine tem suas próprias peculiaridades, mas os conceitos fundamentais de POO permanecem os mesmos.</p>
        
        
    </div>
</div>
    

    <script src="../scripts/script.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</body>
</html>